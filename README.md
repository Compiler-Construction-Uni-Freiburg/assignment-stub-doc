# Purpose

This document should serve as a quick guide to the provided assignment stub. It will be continously updated for new assignments, if necessary.

# Files

## `compiler.py`
Contains the `Compiler` class.
All passes of the compiler are implemented here.

## `utils.py`
Contains:
- `__repr__` and `__str__` methods that replace those of the python `ast` module
- Helper functions, e.g. `generate_name` to create unique ids which may be used for temp. variables
- `__eq__` and `__hash__` methods for `Name` of the python `ast` module
- Functions for test infrastructure (see below).

## `interp_Pvar.py`
Interpreter for the `Lvar` language. Used for tests after the individual compiler passes.

## `x86_ast.py`
Contains the abstract syntax tree for x86 programs, used by the x86 interpreter in the `interp_x86` dir. **This is the target language of your compiler.**

# Testing infrastructure
## `tests` directory:
- Contains tests for specific languages. Old languages will be used as regression tests when extending the compiler for new language features.
- Each test consists of three files:
	1. `.py` file containing the program to compile
	2. `.in` file containing the input to be fed to `stdin` of the program
	3. `.golden` file containing the expected output of your compiled program
- After you run a test, additional files will be generated:
	1. `.s` file containing the assembler code generated by your compiler
	2. `.out` file containing the actual output from running your compiled program  
## `run-tests.py` file:
- Creates a `Compiler` object and calls `run_tests` from `utils.py` to execute tests.
- To run tests for a new language, e.g. `lang` (with tests in the directory `/tests/lang`), add the following line to the bottom of the file: `run_tests("lang", compiler, "lang", None, interp_Pvar.InterpPvar().interp_P, None, None)`
## `run_tests` function inside `utils.py`: 
- Parameters: language, `Compiler` object, type checker, interpreter. Also takes type checker and interpreter for an intermediate language.
- Function: Executes all tests found in `/tests/language` folder. This is done using `run_one_test`/`compile_and_test`.
## Function(s) `run_one_test`/`compile_and_test` inside `utils.py`:
- Runs all relevant passes of the `Compiler` object on a test
- Compares output from x86 interpreter found in the `interp_x86` dir on your compiled program with relevant `.golden` file
- If you wish, you can set `test_x86 = True`. Then, after each pass where it is applicable, the pass output will be interpreted using the x86 interpreter, and the result compared to the relevant `.golden` file.
## `enable_tracing` inside `utils.py`
- **Enables much more verbose test output for compiler passes.**

---

## Important note on Github Classroom tests
Local tests may pass while tests from Github Classroom Workflow fail. This is because in the Workflow,
instead of using an x86 interpreter for the tests, binaries are compiled using `gcc` and then run. The interpreter is more lax and allows, for example, segmentation faults.

##  What to do when tests fail
- Check generated `.s` and `.output` files in `tests/*` directory. If there is `None` somewhere, one of your passes might miss a case.
- Set `test_x86` to `True` in the `compile_and_test` function. This will show you if one of your x86 passes fails.
